{"ast":null,"code":"'use strict';\n\nvar globalThis = require('../internals/global-this');\n\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\n\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\n\nvar defineBuiltIn = require('../internals/define-built-in');\n\nvar defineGlobalProperty = require('../internals/define-global-property');\n\nvar copyConstructorProperties = require('../internals/copy-constructor-properties');\n\nvar isForced = require('../internals/is-forced');\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\n\n\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n\n  if (GLOBAL) {\n    target = globalThis;\n  } else if (STATIC) {\n    target = globalThis[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = globalThis[TARGET] && globalThis[TARGET].prototype;\n  }\n\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target\n\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    } // add a flag to not completely full polyfills\n\n\n    if (options.sham || targetProperty && targetProperty.sham) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n\n    defineBuiltIn(target, key, sourceProperty, options);\n  }\n};","map":{"version":3,"sources":["C:/Users/carli/OneDrive/Escritorio/Dev/astrid/InteriorDesing/node_modules/core-js/internals/export.js"],"names":["globalThis","require","getOwnPropertyDescriptor","f","createNonEnumerableProperty","defineBuiltIn","defineGlobalProperty","copyConstructorProperties","isForced","module","exports","options","source","TARGET","target","GLOBAL","global","STATIC","stat","FORCED","key","targetProperty","sourceProperty","descriptor","prototype","dontCallGetSet","value","forced","undefined","sham"],"mappings":"AAAA;;AACA,IAAIA,UAAU,GAAGC,OAAO,CAAC,0BAAD,CAAxB;;AACA,IAAIC,wBAAwB,GAAGD,OAAO,CAAC,iDAAD,CAAP,CAA2DE,CAA1F;;AACA,IAAIC,2BAA2B,GAAGH,OAAO,CAAC,6CAAD,CAAzC;;AACA,IAAII,aAAa,GAAGJ,OAAO,CAAC,8BAAD,CAA3B;;AACA,IAAIK,oBAAoB,GAAGL,OAAO,CAAC,qCAAD,CAAlC;;AACA,IAAIM,yBAAyB,GAAGN,OAAO,CAAC,0CAAD,CAAvC;;AACA,IAAIO,QAAQ,GAAGP,OAAO,CAAC,wBAAD,CAAtB;AAEA;;;;;;;;;;;;;;;;;AAeAQ,MAAM,CAACC,OAAP,GAAiB,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC1C,MAAIC,MAAM,GAAGF,OAAO,CAACG,MAArB;AACA,MAAIC,MAAM,GAAGJ,OAAO,CAACK,MAArB;AACA,MAAIC,MAAM,GAAGN,OAAO,CAACO,IAArB;AACA,MAAIC,MAAJ,EAAYL,MAAZ,EAAoBM,GAApB,EAAyBC,cAAzB,EAAyCC,cAAzC,EAAyDC,UAAzD;;AACA,MAAIR,MAAJ,EAAY;AACVD,IAAAA,MAAM,GAAGd,UAAT;AACD,GAFD,MAEO,IAAIiB,MAAJ,EAAY;AACjBH,IAAAA,MAAM,GAAGd,UAAU,CAACa,MAAD,CAAV,IAAsBP,oBAAoB,CAACO,MAAD,EAAS,EAAT,CAAnD;AACD,GAFM,MAEA;AACLC,IAAAA,MAAM,GAAGd,UAAU,CAACa,MAAD,CAAV,IAAsBb,UAAU,CAACa,MAAD,CAAV,CAAmBW,SAAlD;AACD;;AACD,MAAIV,MAAJ,EAAY,KAAKM,GAAL,IAAYR,MAAZ,EAAoB;AAC9BU,IAAAA,cAAc,GAAGV,MAAM,CAACQ,GAAD,CAAvB;;AACA,QAAIT,OAAO,CAACc,cAAZ,EAA4B;AAC1BF,MAAAA,UAAU,GAAGrB,wBAAwB,CAACY,MAAD,EAASM,GAAT,CAArC;AACAC,MAAAA,cAAc,GAAGE,UAAU,IAAIA,UAAU,CAACG,KAA1C;AACD,KAHD,MAGOL,cAAc,GAAGP,MAAM,CAACM,GAAD,CAAvB;;AACPD,IAAAA,MAAM,GAAGX,QAAQ,CAACO,MAAM,GAAGK,GAAH,GAASP,MAAM,IAAII,MAAM,GAAG,GAAH,GAAS,GAAnB,CAAN,GAAgCG,GAAhD,EAAqDT,OAAO,CAACgB,MAA7D,CAAjB,CAN8B,CAO9B;;AACA,QAAI,CAACR,MAAD,IAAWE,cAAc,KAAKO,SAAlC,EAA6C;AAC3C,UAAI,OAAON,cAAP,IAAyB,OAAOD,cAApC,EAAoD;AACpDd,MAAAA,yBAAyB,CAACe,cAAD,EAAiBD,cAAjB,CAAzB;AACD,KAX6B,CAY9B;;;AACA,QAAIV,OAAO,CAACkB,IAAR,IAAiBR,cAAc,IAAIA,cAAc,CAACQ,IAAtD,EAA6D;AAC3DzB,MAAAA,2BAA2B,CAACkB,cAAD,EAAiB,MAAjB,EAAyB,IAAzB,CAA3B;AACD;;AACDjB,IAAAA,aAAa,CAACS,MAAD,EAASM,GAAT,EAAcE,cAAd,EAA8BX,OAA9B,CAAb;AACD;AACF,CA9BD","sourcesContent":["'use strict';\nvar globalThis = require('../internals/global-this');\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar defineBuiltIn = require('../internals/define-built-in');\nvar defineGlobalProperty = require('../internals/define-global-property');\nvar copyConstructorProperties = require('../internals/copy-constructor-properties');\nvar isForced = require('../internals/is-forced');\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = globalThis;\n  } else if (STATIC) {\n    target = globalThis[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = globalThis[TARGET] && globalThis[TARGET].prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn(target, key, sourceProperty, options);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}